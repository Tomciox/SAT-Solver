//C++ Abstract Syntax Implementation generated by the BNF Converter.
#include <algorithm>
#include <string>
#include <iostream>
#include <vector>
#include "Absyn.H"

/********************   EIff    ********************/
EIff::EIff(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

EIff::EIff(const EIff & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

EIff &EIff::operator=(const EIff & other)
{
  EIff tmp(other);
  swap(tmp);
  return *this;
}

void EIff::swap(EIff & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

EIff::~EIff()
{
  delete(exp_1);
  delete(exp_2);

}

void EIff::accept(Visitor *v)
{
  v->visitEIff(this);
}

EIff *EIff::clone() const
{
  return new EIff(*this);
}

int EIff::tseytin_transformation(std::vector <std::vector<Literal>> &tseytin, int n) const {

  int m = exp_1->tseytin_transformation(tseytin, n + 1);
  int m2 = exp_2->tseytin_transformation(tseytin, m);

  std::string a = "y_" + std::to_string(n),
              b = "y_" + std::to_string(n + 1),
              c = "y_" + std::to_string(m);

  tseytin.push_back({Literal(false, a), Literal(false, b), Literal(true, c)});
  tseytin.push_back({Literal(false, a), Literal(true, b), Literal(false, b)});
  tseytin.push_back({Literal(true, a), Literal(false, b), Literal(false, c)});
  tseytin.push_back({Literal(true, a), Literal(true, b), Literal(true, c)});

  return m2;
}


/********************   EImplies    ********************/
EImplies::EImplies(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

EImplies::EImplies(const EImplies & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

EImplies &EImplies::operator=(const EImplies & other)
{
  EImplies tmp(other);
  swap(tmp);
  return *this;
}

void EImplies::swap(EImplies & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

EImplies::~EImplies()
{
  delete(exp_1);
  delete(exp_2);

}

void EImplies::accept(Visitor *v)
{
  v->visitEImplies(this);
}

EImplies *EImplies::clone() const
{
  return new EImplies(*this);
}

int EImplies::tseytin_transformation(std::vector <std::vector<Literal>> &tseytin, int n) const {

  int m = exp_1->tseytin_transformation(tseytin, n + 1);
  int m2 = exp_2->tseytin_transformation(tseytin, m);

  std::string a = "y_" + std::to_string(n),
              b = "y_" + std::to_string(n + 1),
              c = "y_" + std::to_string(m);

  tseytin.push_back({Literal(false, a), Literal(false, b), Literal(true, c)});
  tseytin.push_back({Literal(true, a), Literal(true, b)});
  tseytin.push_back({Literal(true, a), Literal(false, c)});

  return m2;
}

/********************   EOr    ********************/
EOr::EOr(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

EOr::EOr(const EOr & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

EOr &EOr::operator=(const EOr & other)
{
  EOr tmp(other);
  swap(tmp);
  return *this;
}

void EOr::swap(EOr & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

EOr::~EOr()
{
  delete(exp_1);
  delete(exp_2);

}

void EOr::accept(Visitor *v)
{
  v->visitEOr(this);
}

EOr *EOr::clone() const
{
  return new EOr(*this);
}

int EOr::tseytin_transformation(std::vector <std::vector<Literal>> &tseytin, int n) const {

  int m = exp_1->tseytin_transformation(tseytin, n + 1);
  int m2 = exp_2->tseytin_transformation(tseytin, m);

  std::string a = "y_" + std::to_string(n),
              b = "y_" + std::to_string(n + 1),
              c = "y_" + std::to_string(m);

  tseytin.push_back({Literal(false, a), Literal(true, b), Literal(true, c)});
  tseytin.push_back({Literal(true, a), Literal(false, b)});
  tseytin.push_back({Literal(true, a), Literal(false, c)});

  return m2;
}

/********************   EAnd    ********************/
EAnd::EAnd(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

EAnd::EAnd(const EAnd & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

EAnd &EAnd::operator=(const EAnd & other)
{
  EAnd tmp(other);
  swap(tmp);
  return *this;
}

void EAnd::swap(EAnd & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

EAnd::~EAnd()
{
  delete(exp_1);
  delete(exp_2);

}

void EAnd::accept(Visitor *v)
{
  v->visitEAnd(this);
}

EAnd *EAnd::clone() const
{
  return new EAnd(*this);
}

int EAnd::tseytin_transformation(std::vector <std::vector<Literal>> &tseytin, int n) const {

  int m = exp_1->tseytin_transformation(tseytin, n + 1);
  int m2 = exp_2->tseytin_transformation(tseytin, m);

  std::string a = "y_" + std::to_string(n),
              b = "y_" + std::to_string(n + 1),
              c = "y_" + std::to_string(m);

  tseytin.push_back({Literal(false, a), Literal(true, b)});
  tseytin.push_back({Literal(false, a), Literal(true, c)});
  tseytin.push_back({Literal(true, a), Literal(false, b), Literal(false, c)});

  return m2;
}

/********************   ENot    ********************/
ENot::ENot(Exp *p1)
{
  exp_ = p1;

}

ENot::ENot(const ENot & other)
{
  exp_ = other.exp_->clone();

}

ENot &ENot::operator=(const ENot & other)
{
  ENot tmp(other);
  swap(tmp);
  return *this;
}

void ENot::swap(ENot & other)
{
  std::swap(exp_, other.exp_);

}

ENot::~ENot()
{
  delete(exp_);

}

void ENot::accept(Visitor *v)
{
  v->visitENot(this);
}

ENot *ENot::clone() const
{
  return new ENot(*this);
}

int ENot::tseytin_transformation(std::vector <std::vector<Literal>> &tseytin, int n) const {

  int m = exp_->tseytin_transformation(tseytin, n + 1);

  std::string a = "y_" + std::to_string(n),
              b = "y_" + std::to_string(n + 1);

  tseytin.push_back({Literal(false, a), Literal(false, b)});
  tseytin.push_back({Literal(true, a), Literal(true, b)});

  return m;
}

/********************   EVar    ********************/
EVar::EVar(UIdent p1)
{
  uident_ = p1;

}

EVar::EVar(const EVar & other)
{
  uident_ = other.uident_;

}

EVar &EVar::operator=(const EVar & other)
{
  EVar tmp(other);
  swap(tmp);
  return *this;
}

void EVar::swap(EVar & other)
{
  std::swap(uident_, other.uident_);

}

EVar::~EVar()
{

}

void EVar::accept(Visitor *v)
{
  v->visitEVar(this);
}

EVar *EVar::clone() const
{
  return new EVar(*this);
}

int EVar::tseytin_transformation(std::vector <std::vector<Literal>> &tseytin, int n) const {
  std::string a = "y_" + std::to_string(n);
  std::string b = uident_.substr(1, uident_.size() - 2);

  tseytin.push_back({Literal(true, a), Literal(false, b)});
  tseytin.push_back({Literal(false, a), Literal(true, b)});

  return n + 1;
}

/********************   ETrue    ********************/
ETrue::ETrue()
{

}

ETrue::ETrue(const ETrue & other)
{

}

ETrue &ETrue::operator=(const ETrue & other)
{
  ETrue tmp(other);
  swap(tmp);
  return *this;
}

void ETrue::swap(ETrue & other)
{

}

ETrue::~ETrue()
{

}

void ETrue::accept(Visitor *v)
{
  v->visitETrue(this);
}

ETrue *ETrue::clone() const
{
  return new ETrue(*this);
}

int ETrue::tseytin_transformation(std::vector <std::vector<Literal>> &tseytin, int n) const {
  std::string a = "y_" + std::to_string(n);

  tseytin.push_back({Literal(true, a)});

  return n + 1;
}

/********************   EFalse    ********************/
EFalse::EFalse()
{

}

EFalse::EFalse(const EFalse & other)
{

}

EFalse &EFalse::operator=(const EFalse & other)
{
  EFalse tmp(other);
  swap(tmp);
  return *this;
}

void EFalse::swap(EFalse & other)
{

}

EFalse::~EFalse()
{

}

void EFalse::accept(Visitor *v)
{
  v->visitEFalse(this);
}

EFalse *EFalse::clone() const
{
  return new EFalse(*this);
}

int EFalse::tseytin_transformation(std::vector <std::vector<Literal>> &tseytin, int n) const {
  std::string a = "y_" + std::to_string(n);

  tseytin.push_back({Literal(false, a)});

  return n + 1;
}