/*** Compiler Front-End Test automatically generated by the BNF Converter ***/
/*                                                                          */
/* This test will parse a file, print the abstract syntax tree, and then    */
/* pretty-print the result.                                                 */
/*                                                                          */
/****************************************************************************/
#include <stdio.h>
#include "Parser.H"
#include "Printer.H"
#include "Absyn.H"
#include <vector>
#include <set>
#include <map>

typedef std::set<Literal> SL;
typedef std::vector<Literal> VL;
typedef std::vector<VL> VVL;
typedef std::set<std::string> SS;
typedef std::map<std::string, int> MSI;

SL find_one_literal(const VVL &clauses) {
  SL result;
  for (const auto &clause : clauses) {
    if (clause.size() == 1) {
      if (result.find(clause[0].negation()) == result.end())
        result.insert(clause[0]);
      else
        throw std::string("contradiction1");
    }
  }
  return result;
}

SL find_pure_literal(const VVL &clauses) {
  SS positive, negative;
  for (const auto &clause : clauses) {
    for (const auto &literal : clause) {
      if (literal.sign)
        positive.insert(literal.name);
      else
        negative.insert(literal.name);
    }
  }

  SL result;

  for (const auto &literal : positive) {
    if (negative.find(literal) == negative.end())
      result.insert(Literal(true, literal));
  }

  for (const auto &literal : negative) {
    if (positive.find(literal) == positive.end())
      result.insert(Literal(false, literal));
  }

  return result;
}

Literal find_split(const VVL &clauses) {
  MSI positive, negative;
  MSI positive2, negative2;

  for (const auto &clause : clauses) {
    for (const auto &literal : clause) {
      if (literal.sign) {
        positive[literal.name]++;

        if (clause.size() == 2)
          negative2[literal.name]++;
      }
      else {
        negative[literal.name]++;

        if (clause.size() == 2)
          positive2[literal.name]++;
      }
    }
  }

  int maximum = 0;
  std::string name_;
  bool sign_;

  for (const auto &e : positive) {
    int add = 0;

    if (positive2.find(e.first) != positive2.end())
      add = positive2[e.first];

    if (e.second + add > maximum) {
      sign_ = true;
      maximum = e.second + add;
      name_ = e.first;
    }
  }

  for (const auto &e : negative) {
    int add = 0;

    if (negative2.find(e.first) != negative2.end())
      add = negative2[e.first];

    if (e.second + add > maximum) {
      sign_ = false;
      maximum = e.second + add;
      name_ = e.first;
    }
  }

  return Literal(sign_, name_);
}

VVL substitute(const VVL &clauses, SL &values) {
  VVL result_clauses;

  for (const auto &clause : clauses) {
    VL new_clause;
    bool satisfied = false;

    for (const auto &literal : clause) {
      if (values.find(literal) != values.end())
        satisfied = true;

      else if (values.find(literal.negation()) == values.end())
        new_clause.push_back(literal);
    }

    if (!satisfied) {
      if (new_clause.empty())
        throw "contradiction2";
      result_clauses.push_back(new_clause);
    }
  }
  return result_clauses;
}

bool solve(VVL &v) {

  SL l1, l2;

  do {

    try {
      l1 = find_one_literal(v), l2 = find_pure_literal(v);

      if (!l1.empty())
        v = substitute(v, l1);

      if (!l2.empty())
        v = substitute(v, l2);

    } catch (...) {
      return false;
    }

  } while (!l1.empty() || !l2.empty());

  if (v.empty())
    return true;

  SL split{find_split(v)};
  auto left = substitute(v, split);

  if (solve(left))
    return true;

  SL split2{Literal(!split.begin()->sign, split.begin()->name)};
  auto right = substitute(v, split2);

  return solve(right);
}

int main(int argc, char ** argv)
{
  FILE *input;
  if (argc > 1)
  {
    input = fopen(argv[1], "r");
    if (!input)
    {
      fprintf(stderr, "Error opening input file.\n");
      exit(1);
    }
  }
  else input = stdin;
  /* The default entry point is used. For other options see Parser.H */
  Exp *parse_tree = pExp(input);


  if (parse_tree)
  {
    VVL tseytin{{Literal(true, "y_0")}};
    parse_tree->tseytin_transformation(tseytin, 0);
    printf("%d\n", solve(tseytin));

    return 0;
  }
  return 1;
}

