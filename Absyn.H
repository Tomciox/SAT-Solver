#ifndef ABSYN_HEADER
#define ABSYN_HEADER

#include<string>
#include<vector>
#include<set>


class Literal {
public:
  bool sign;
  std::string name;

  Literal(bool sign_ = false, std::string name_ = "NULL") : sign(sign_), name(name_) {}

  std::string to_string() {
    return (!this->sign ? "~" : "") + this->name;
  }

  bool operator==(const Literal &l) {
    return this->name == l.name;
  }

  bool operator!=(const Literal &l) {
    return !(this->operator==(l));
  }

  bool operator<(const Literal &l) const {
    if (this->name == l.name)
      return this->sign < l.sign;
    return this->name < l.name;
  }

  Literal negation() const {
    return Literal(!sign, name);
  }
};

typedef std::vector <std::vector<Literal>> VVL;

//C++ Abstract Syntax Interface generated by the BNF Converter.

/********************   TypeDef Section    ********************/

typedef int Integer;
typedef char Char;
typedef double Double;
typedef std::string String;
typedef std::string Ident;


typedef std::string UIdent;


/********************   Forward Declarations    ********************/

class Exp;
class EIff;
class EImplies;
class EOr;
class EAnd;
class ENot;
class EVar;
class ETrue;
class EFalse;


/********************   Visitor Interfaces    ********************/
class Visitor
{
public:
  virtual ~Visitor() {}
  virtual void visitExp(Exp *p) = 0;
  virtual void visitEIff(EIff *p) = 0;
  virtual void visitEImplies(EImplies *p) = 0;
  virtual void visitEOr(EOr *p) = 0;
  virtual void visitEAnd(EAnd *p) = 0;
  virtual void visitENot(ENot *p) = 0;
  virtual void visitEVar(EVar *p) = 0;
  virtual void visitETrue(ETrue *p) = 0;
  virtual void visitEFalse(EFalse *p) = 0;


  virtual void visitInteger(Integer x) = 0;
  virtual void visitChar(Char x) = 0;
  virtual void visitDouble(Double x) = 0;
  virtual void visitString(String x) = 0;
  virtual void visitIdent(Ident x) = 0;
  virtual void visitUIdent(UIdent x) = 0;

};


class Visitable
{
public:
  virtual ~Visitable() {}
  virtual void accept(Visitor *v) = 0;
};


/********************   Abstract Syntax Classes    ********************/

class Exp : public Visitable
{
public:
  virtual Exp *clone() const = 0;
  virtual int tseytin_transformation(VVL &tseytin, int n) const = 0;
};



class EIff : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  EIff(const EIff &);
  EIff &operator=(const EIff &);
  EIff(Exp *p1, Exp *p2);
  ~EIff();
  virtual void accept(Visitor *v);
  virtual EIff *clone() const;
  void swap(EIff &);

  int tseytin_transformation(VVL &tseytin, int n) const;
};

class EImplies : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  EImplies(const EImplies &);
  EImplies &operator=(const EImplies &);
  EImplies(Exp *p1, Exp *p2);
  ~EImplies();
  virtual void accept(Visitor *v);
  virtual EImplies *clone() const;
  void swap(EImplies &);

  int tseytin_transformation(VVL &tseytin, int n) const;
};

class EOr : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  EOr(const EOr &);
  EOr &operator=(const EOr &);
  EOr(Exp *p1, Exp *p2);
  ~EOr();
  virtual void accept(Visitor *v);
  virtual EOr *clone() const;
  void swap(EOr &);

  int tseytin_transformation(VVL &tseytin, int n) const;
};

class EAnd : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  EAnd(const EAnd &);
  EAnd &operator=(const EAnd &);
  EAnd(Exp *p1, Exp *p2);
  ~EAnd();
  virtual void accept(Visitor *v);
  virtual EAnd *clone() const;
  void swap(EAnd &);

  int tseytin_transformation(VVL &tseytin, int n) const;
};

class ENot : public Exp
{
public:
  Exp *exp_;

  ENot(const ENot &);
  ENot &operator=(const ENot &);
  ENot(Exp *p1);
  ~ENot();
  virtual void accept(Visitor *v);
  virtual ENot *clone() const;
  void swap(ENot &);

  int tseytin_transformation(VVL &tseytin, int n) const;
};

class EVar : public Exp
{
public:
  UIdent uident_;

  EVar(const EVar &);
  EVar &operator=(const EVar &);
  EVar(UIdent p1);
  ~EVar();
  virtual void accept(Visitor *v);
  virtual EVar *clone() const;
  void swap(EVar &);

  int tseytin_transformation(VVL &tseytin, int n) const;
};

class ETrue : public Exp
{
public:

  ETrue(const ETrue &);
  ETrue &operator=(const ETrue &);
  ETrue();
  ~ETrue();
  virtual void accept(Visitor *v);
  virtual ETrue *clone() const;
  void swap(ETrue &);

  int tseytin_transformation(VVL &tseytin, int n) const;
};

class EFalse : public Exp
{
public:

  EFalse(const EFalse &);
  EFalse &operator=(const EFalse &);
  EFalse();
  ~EFalse();
  virtual void accept(Visitor *v);
  virtual EFalse *clone() const;
  void swap(EFalse &);

  int tseytin_transformation(VVL &tseytin, int n) const;
};

#endif
